<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>AI Shorts Pro Maker (v2.1)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/coi-serviceworker/0.1.7/coi-serviceworker.min.js"></script>
    <script src="https://unpkg.com/fabric@5.3.0/dist/fabric.min.js"></script>
    <script src="https://unpkg.com/@ffmpeg/ffmpeg@0.12.7/dist/umd/ffmpeg.min.js"></script>
    <script src="https://unpkg.com/@ffmpeg/util@0.12.1/dist/umd/index.js"></script>
    <style>
        body { font-family: 'Pretendard', sans-serif; background: #121212; color: white; display: flex; flex-direction: column; align-items: center; }
        #canvas-wrapper { width: 360px; height: 640px; border: 2px solid #333; margin-top: 20px; overflow: hidden; position: relative; background: #000; }
        .ui-panel { width: 360px; margin-top: 20px; display: flex; flex-direction: column; gap: 10px; }
        input, select, button { padding: 12px; border-radius: 8px; border: none; font-size: 16px; }
        button { background: #007AFF; color: white; font-weight: bold; cursor: pointer; }
        button:disabled { background: #444; cursor: not-allowed; }
        #progress-container { width: 100%; height: 10px; background: #333; border-radius: 5px; overflow: hidden; margin-top: 10px; display: none; }
        #progress-bar { height: 100%; width: 0%; background: #007AFF; transition: width 0.3s; }
        #log { font-size: 14px; color: #aaa; margin-top: 10px; text-align: center; min-height: 20px; word-break: break-all; }
        .error { color: #ff4d4d; }
    </style>
</head>
<body>
    <h1>AI Shorts Pro (개선판)</h1>
    <div id="canvas-wrapper"><canvas id="canvas"></canvas></div>
    <div class="ui-panel">
        <input type="text" id="topic" placeholder="쇼츠 주제 (예: 1분 명상 팁)">
        <select id="language">
            <option value="ko-KR">한국어</option>
            <option value="en-US">English</option>
        </select>
        <button id="main-btn" onclick="runWorkflow()">1. AI 쇼츠 기획 시작</button>
        <button id="export-btn" onclick="exportShorts()" disabled>2. 영상 생성 및 다운로드</button>
        <div id="progress-container"><div id="progress-bar"></div></div>
        <div id="log">주제를 입력하고 시작 버튼을 누르세요.</div>
    </div>

    <script>
        // ▼▼▼ [중요] 여기에 본인의 API 키를 반드시 입력하세요! ▼▼▼
        const GEMINI_KEY = ""; // 예: "AIzaSyATO2o2YnoaT9m4bE0gSs4m3vPkAoqWM00"
        const PEXELS_KEY = ""; // 예: "563492ad6f91700001000001..."
        // ▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲

        const canvas = new fabric.Canvas('canvas', { width: 360, height: 640, backgroundColor: '#000' });
        let currentScript = null;
        let ffmpeg = null;

        // --- [1부] AI 기획 및 구성 워크플로우 ---
        async function runWorkflow() {
            if (!GEMINI_KEY) { alert("AIzaSyAtzf9qkosqyr6ct68t4b-H46-BZmLewkI"); return; }
            if (!PEXELS_KEY) { alert("RoENgvlFuwNUfjxMbeMxUguWn8ENueJFWGDSj2kfHaBHok0xlnV7SyLT"); return; }

            const topic = document.getElementById('topic').value;
            if (!topic) { alert("주제를 입력해주세요."); return; }
            const lang = document.getElementById('language').value;
            
            setUIState(true, "AI가 시나리오를 구상 중입니다...");

            try {
                // 1. Gemini 대본 생성 (개선된 함수 사용)
                const script = await getGeminiData(topic, lang);
                currentScript = script;
                updateLog(`시나리오 완성! (길이: ${script.total_duration}초) 배경 이미지를 찾습니다...`);

                // 2. Pexels 이미지 매칭 (병렬 처리로 속도 향상)
                const imagePromises = script.scenes.map(async (scene) => {
                    scene.bgImage = await fetchPexelsImage(scene.visual_prompt);
                    return scene;
                });
                await Promise.all(imagePromises);

                // 3. 첫 장면 미리보기 렌더링
                renderSceneAtTime(0);
                updateLog("준비 완료! '영상 생성' 버튼을 눌러주세요.");
                document.getElementById('export-btn').disabled = false;

            } catch (e) {
                console.error(e);
                // 에러 원인을 화면에 표시
                updateLog(`오류 발생: ${e.message}`);
                alert(`진행 중 문제가 발생했습니다.\n원인: ${e.message}`);
            } finally {
                setUIState(false);
            }
        }

        // --- [2부] 영상 렌더링 코어 (시각화 및 속도 최적화) ---
        async function exportShorts() {
            if (!currentScript) return;
            setUIState(true, "FFmpeg 엔진을 준비 중입니다...");
            document.getElementById('progress-container').style.display = 'block';
            updateProgress(0);

            try {
                if (!ffmpeg) {
                    ffmpeg = new FFmpeg.FFmpeg();
                    ffmpeg.on('log', ({ message }) => console.log(message));
                    await ffmpeg.load({
                        coreURL: await FFmpegUtil.toBlobURL('https://unpkg.com/@ffmpeg/core@0.12.6/dist/umd/ffmpeg-core.js', 'text/javascript'),
                        wasmURL: await FFmpegUtil.toBlobURL('https://unpkg.com/@ffmpeg/core@0.12.6/dist/umd/ffmpeg-core.wasm', 'application/wasm'),
                    });
                }

                const fps = 12; // 속도 최우선 설정 (12fps)
                const totalFrames = Math.ceil(currentScript.total_duration * fps);

                updateLog(`총 ${totalFrames}개 프레임을 렌더링하며 캡처합니다...`);
                
                for (let i = 0; i < totalFrames; i++) {
                    const currentTime = i / fps;
                    renderSceneAtTime(currentTime);
                    await new Promise(resolve => setTimeout(resolve, 0)); // UI 업데이트 양보

                    // JPEG 품질 0.7로 속도 최적화
                    const frameData = canvas.toDataURL('image/jpeg', 0.7);
                    const data = await FFmpegUtil.fetchFile(frameData);
                    await ffmpeg.writeFile(`frame${i}.jpg`, data);
                    
                    updateProgress(((i + 1) / totalFrames) * 50);
                }

                updateLog("인코딩 중... (잠시만 기다려주세요)");
                
                await ffmpeg.exec([
                    '-framerate', `${fps}`,
                    '-i', 'frame%d.jpg',
                    '-c:v', 'libx264',
                    '-preset', 'ultrafast', // 속도 최우선 프리셋
                    '-tune', 'stillimage',
                    '-pix_fmt', 'yuv420p',
                    'output.mp4'
                ]);
                updateProgress(100);

                const data = await ffmpeg.readFile('output.mp4');
                const url = URL.createObjectURL(new Blob([data.buffer], { type: 'video/mp4' }));
                const a = document.createElement('a');
                a.href = url;
                a.download = `${document.getElementById('topic').value.replace(/\s+/g, '_')}_shorts.mp4`;
                a.click();
                updateLog("완료! 파일이 다운로드되었습니다.");

            } catch (e) {
                console.error(e);
                updateLog(`인코딩 실패: ${e.message}`);
                alert("영상 생성에 실패했습니다. (GitHub Pages 보안 설정 문제일 수 있습니다)");
            } finally {
                setUIState(false);
                setTimeout(() => { document.getElementById('progress-container').style.display = 'none'; }, 3000);
            }
        }

        // --- [보조 함수들] ---
        function renderSceneAtTime(time) {
            canvas.clear();
            const scene = currentScript.scenes.find(s => time >= s.start && time < s.end) || currentScript.scenes[currentScript.scenes.length-1];
            
            if (scene && scene.bgImage) {
                fabric.Image.fromURL(scene.bgImage, (img) => {
                    const scale = Math.max(canvas.width / img.width, canvas.height / img.height);
                    img.set({ scaleX: scale, scaleY: scale, originX: 'center', originY: 'center', left: canvas.width/2, top: canvas.height/2, selectable: false });
                    canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas));
                    
                    if (scene.text) {
                        const text = new fabric.Textbox(scene.text, {
                            width: 320, top: 480, left: 180, originX: 'center', textAlign: 'center',
                            fill: currentScript.theme?.txt || '#ffffff',
                            fontSize: 26, fontWeight: 'bold',
                            backgroundColor: 'rgba(0,0,0,0.6)', padding: 10, rx: 10, ry: 10, selectable: false
                        });
                        canvas.add(text);
                    }
                }, { crossOrigin: 'anonymous' });
            }
        }

        // ▼▼▼ [가장 중요한 개선점] JSON 파싱 로직 강화 ▼▼▼
        async function getGeminiData(topic, lang) {
            const prompt = `주제 "${topic}"로 ${lang} 쇼츠 대본 작성. 8~45초 이내. 결과는 오직 JSON만 출력: {"total_duration":초,"theme":{"txt":"#hex색상"},"scenes":[{"start":0,"end":초,"text":"짧은자막","visual_prompt":"영문이미지검색어"}]}`;
            
            const resp = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${GEMINI_KEY}`, {
                method: 'POST', headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
            });
            
            if (!resp.ok) throw new Error(`API 호출 실패 (${resp.status})`);
            
            const json = await resp.json();
            let rawText = json.candidates[0].content.parts[0].text;
            
            // 1. 마크다운 백틱(```json) 제거
            rawText = rawText.replace(/```json|```/g, "").trim();
            
            // 2. 정규표현식으로 가장 바깥쪽 중괄호 {} 만 추출 (혹시 모를 앞뒤 잡설 제거)
            const jsonMatch = rawText.match(/\{[\s\S]*\}/);
            if (!jsonMatch) throw new Error("AI 응답에서 유효한 JSON을 찾지 못했습니다.");
            
            return JSON.parse(jsonMatch[0]);
        }
        // ▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲

        async function fetchPexelsImage(query) {
            try {
                const resp = await fetch(`https://api.pexels.com/v1/search?query=${query}&per_page=1`, { headers: { Authorization: PEXELS_KEY } });
                const data = await resp.json();
                return data.photos.length > 0 ? data.photos[0].src.large2x : null;
            } catch (e) { console.warn("이미지 검색 실패:", query); return null; }
        }

        function setUIState(isLoading, msg) {
            document.getElementById('main-btn').disabled = isLoading;
            document.getElementById('export-btn').disabled = isLoading || !currentScript;
            const log = document.getElementById('log');
            log.innerText = msg || "";
            log.classList.remove('error'); // 에러 상태 해제
        }
        function updateLog(msg) { 
            const log = document.getElementById('log');
            log.innerText = msg;
            if (msg.startsWith("오류") || msg.startsWith("인코딩 실패")) log.classList.add('error');
        }
        function updateProgress(percent) { document.getElementById('progress-bar').style.width = `${percent}%`; }
    </script>
</body>
</html>